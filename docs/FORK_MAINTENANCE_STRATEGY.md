# Fork Maintenance Strategy

This document defines how we maintain the `aronchick/multiclaude` fork while contributing back to `dlorenc/multiclaude` upstream.

## Philosophy

**Upstream First, Fork Second**: We contribute everything possible to upstream. The fork only contains features that upstream explicitly rejects or are specific to our use case.

## Upstream Scope (What Dan/dlorenc Accepts)

Based on ROADMAP.md and DESIGN.md, upstream accepts:

‚úÖ **Core functionality improvements**
- Bug fixes
- Performance improvements
- Better error messages
- Agent lifecycle improvements
- Worktree management
- CI/testing improvements

‚úÖ **Developer experience**
- Better CLI commands
- Improved documentation
- Local development tools (Makefile, pre-commit hooks)
- Crash recovery

‚úÖ **Agent intelligence**
- Better prompts
- Fork detection and workflow guidance
- Upstream sync automation
- PR scope enforcement

## Upstream Rejects (Fork-Only Features)

Based on ROADMAP.md "Out of Scope" section:

‚ùå **Web interfaces or dashboards**
- No REST APIs for external consumption
- No browser-based UIs
- Terminal is the interface

‚ùå **Remote/hybrid deployment**
- No cloud coordination
- No distributed orchestration

‚ùå **Multi-provider support**
- Claude-only, no OpenAI/Gemini/etc.

‚ùå **External integrations**
- No Slack, Discord, etc. (not terminal-native)
- No issue tracker integrations beyond GitHub

## Fork-Specific Features to Maintain

### 1. Slack Integration (Planned)

**Location**: `internal/integrations/slack/`

**Purpose**: Send notifications about agent activity, PR status, CI failures

**Maintenance Strategy**:
- Keep as a separate package that doesn't touch core code
- Use daemon hooks/events to trigger notifications
- Document clearly as fork-only feature
- Disable by default (opt-in via config)

**Implementation Approach**:
```go
// internal/integrations/slack/client.go
// Fork-only: Slack notifications for multiclaude events
```

### 2. Web Dashboard (Planned)

**Location**: `cmd/multiclaude-web/` and `web/`

**Purpose**: View status of all multiclaude instances across multiple machines

**Maintenance Strategy**:
- Separate binary (`multiclaude-web`) that reads state.json
- Read-only view of daemon state
- No control plane (stays terminal-native for core)
- Optional component, not required for core functionality

**Implementation Approach**:
```
cmd/multiclaude-web/     # Separate web server binary
web/                     # Static assets
  ‚îú‚îÄ‚îÄ index.html
  ‚îú‚îÄ‚îÄ dashboard.js
  ‚îî‚îÄ‚îÄ styles.css
```

### 3. Fork-Specific Configuration

**Location**: `.multiclaude/fork-config.json`

**Purpose**: Configuration for fork-only features

**Example**:
```json
{
  "integrations": {
    "slack": {
      "enabled": false,
      "webhook_url": "",
      "notify_on": ["pr_created", "ci_failed", "worker_stuck"]
    },
    "web_dashboard": {
      "enabled": false,
      "port": 8080,
      "read_only": true
    }
  }
}
```

## Merge Strategy

### Merging to Fork Main

1. **Test locally first**: `make check-all`
2. **Merge to fork/main**: All PRs go here first
3. **Evaluate for upstream**: Does it fit upstream scope?
   - ‚úÖ Yes ‚Üí Create upstream PR from feature branch
   - ‚ùå No ‚Üí Keep in fork, document as fork-only

### Syncing from Upstream

```bash
# Every week or when upstream has significant changes
git fetch upstream
git checkout main
git merge upstream/main
git push origin main

# Handle conflicts carefully - preserve fork-only features
```

### Creating Upstream PRs

```bash
# Work on feature branch
git checkout -b feat/better-error-messages

# Make changes, test locally
make check-all

# Push to fork
git push origin feat/better-error-messages

# Create PR to UPSTREAM (not fork)
gh pr create --repo dlorenc/multiclaude \
  --title "feat: Better error messages for git failures" \
  --body "Improves error messages with specific suggestions..."
```

## Branching Strategy

### Branch Naming Conventions

**For upstream-bound features:**
- `upstream/<feature-name>` - Features ready for upstream contribution
- Example: `upstream/ci-guard-rails`, `upstream/task-history`
- These branches should be created from `upstream/main` when submitting PRs
- Cherry-pick relevant commits from fork/main

**For fork-only features:**
- `fork/<feature-name>` - Features that will stay in the fork
- Example: `fork/web-dashboard`, `fork/slack-integration`
- These branches are created from fork's `main`
- Never create upstream PRs from these branches

**For general features (undecided):**
- `feat/<feature-name>` - Standard feature branches
- Example: `feat/better-error-messages`
- Merged to fork/main first, then evaluated for upstream

**For multiclaude workers:**
- `multiclaude/<worker-name>` - Auto-generated by workers
- Example: `multiclaude/gentle-fox`
- These follow normal feature workflow

### Branch Workflow

```bash
# Standard workflow - feature to fork first
git checkout -b feat/my-feature main
# ... make changes ...
git push origin feat/my-feature
gh pr create --base main  # PR to fork

# After merging to fork, if upstream-ready:
git checkout -b upstream/my-feature upstream/main
git cherry-pick <relevant-commits>
git push origin upstream/my-feature
gh pr create --repo dlorenc/multiclaude --base main --head aronchick:upstream/my-feature

# Fork-only workflow
git checkout -b fork/my-fork-feature main
# ... make changes ...
git push origin fork/my-fork-feature
gh pr create --base main --label fork-only
```

## GitHub Labels

### Label Definitions

| Label | Purpose | When to Use | Color |
|-------|---------|-------------|-------|
| `upstream-ready` | Feature ready to contribute upstream | Applied after merging to fork/main when feature fits upstream scope | Green (#0E8A16) |
| `upstream-pending` | Feature with pending upstream PR | Applied when upstream PR is created | Yellow (#FBCA04) |
| `fork-only` | Feature that stays in fork | Applied to features upstream explicitly rejects | Red (#d73a4a) |
| `scope-mismatch` | PR violates scope discipline | Applied by merge-queue when PR bundles multiple unrelated changes | Red (#B60205) |
| `scope-override-approved` | Approved scope exception | Applied by humans when scope violation is justified | Light Blue (#C5DEF5) |
| `multiclaude` | PR created by worker agent | Auto-applied by multiclaude CLI | Blue (#0366d6) |

### Label Workflow

**When creating PR to fork:**
1. If feature is fork-specific (web dashboard, integrations): Add `fork-only`
2. If feature could go upstream: No label yet, wait for merge
3. Multiclaude workers automatically get `multiclaude` label

**After merging to fork:**
1. Evaluate if feature fits upstream scope (see ROADMAP.md)
2. If yes: Add `upstream-ready` label to merged PR
3. If no: Add `fork-only` label and document why

**When creating upstream PR:**
1. Add `upstream-pending` label to the fork PR
2. Link the upstream PR URL in fork PR description
3. Track upstream PR status in UPSTREAM_CONTRIBUTION_PLAN.md

**Scope enforcement:**
1. Merge-queue checks PR scope during review
2. If scope mismatch detected: Add `scope-mismatch` label and block merge
3. Worker must split PR or human must approve with `scope-override-approved`

### Example Label Flow

```bash
# Create fork-only feature
gh pr create --base main --label fork-only --title "feat: Add web dashboard"

# Create upstream-ready feature
gh pr create --base main --title "feat: Better error messages"
# After merge, if upstream-ready:
gh pr edit 123 --add-label upstream-ready

# Create upstream PR
gh pr create --repo dlorenc/multiclaude --base main \
  --head aronchick:upstream/better-errors --title "feat: Better error messages"
# Then update fork PR:
gh pr edit 123 --add-label upstream-pending

# Scope mismatch (applied by merge-queue)
gh pr edit 124 --add-label scope-mismatch
gh pr comment 124 --body "This PR bundles multiple unrelated changes..."

# Human override (when justified)
gh pr edit 124 --remove-label scope-mismatch --add-label scope-override-approved
gh pr comment 124 --body "Approved: This refactor necessarily touches many files"
```

## File Organization

### Core Files (Sync with Upstream)
- `cmd/multiclaude/` - Main CLI
- `internal/` - All core packages (except integrations/)
- `pkg/` - Public libraries
- `test/` - Tests
- `docs/` - Documentation (except fork-specific)

### Fork-Only Files (Never Upstream)
- `internal/integrations/` - External integrations
- `cmd/multiclaude-web/` - Web dashboard
- `web/` - Web assets
- `docs/FORK_MAINTENANCE_STRATEGY.md` - This file
- `.multiclaude/fork-config.json` - Fork configuration

## Contribution Workflow

### For Core Features (Upstream-Bound)

1. Create feature branch: `feat/feature-name`
2. Develop and test locally
3. Create PR to **fork** first
4. Merge to fork/main after review
5. Create PR to **upstream** from same branch
6. If upstream accepts: ‚úÖ Done
7. If upstream rejects: Document why, keep in fork

### For Fork-Only Features

1. Create feature branch: `fork/feature-name` (prefix with `fork/`)
2. Develop in isolation from core
3. Create PR to **fork** only
4. Document as fork-only in PR description
5. Never create upstream PR

## Testing Fork-Only Features

```bash
# Test core + fork features
make check-all

# Test only core (what upstream tests)
go test ./cmd/multiclaude/... ./internal/... ./pkg/... ./test/...

# Test only fork features
go test ./internal/integrations/... ./cmd/multiclaude-web/...
```

## Documentation Strategy

### Upstream Documentation
- README.md - Core features only
- CONTRIBUTING.md - Upstream contribution guide
- AGENTS.md, CLAUDE.md, DESIGN.md - Core architecture

### Fork Documentation
- docs/FORK_MAINTENANCE_STRATEGY.md - This file
- docs/SLACK_INTEGRATION.md - Slack setup (fork-only)
- docs/WEB_DASHBOARD.md - Dashboard setup (fork-only)
- README_FORK.md - Fork-specific features and setup

## Version Management

We don't maintain separate version numbers. Instead:

- Fork tracks upstream main branch
- Fork-only features are additive (don't break core)
- Use git tags for fork releases: `fork-v1.0.0`

## When Upstream Rejects a PR

1. **Understand why**: Read feedback carefully
2. **Document decision**: Add to this file
3. **Keep in fork**: If feature is valuable to us
4. **Maintain separately**: Ensure it doesn't conflict with upstream changes
5. **Revisit periodically**: Upstream scope may change

## Current Status

### Merged to Fork ‚úÖ
- Enhanced task history (#21)
- Settings.json copying (#22)
- Automatic worktree sync (#23)
- Worktree creation fixes (#24)
- `multiclaude nuke` command (#25)
- Smart error detection (#26)
- Agent restart command (#27)

### Pending Fork Merge üîÑ
- CI guard rails (#46)
- Fork-aware workflows (#47)
- Upstream sync enforcement (#48)
- Aggressive PR pushing (#49)
- Dual-layer CI design (#50)

### Planned Fork-Only Features üìã
- Slack integration
- Web dashboard
- Multi-machine monitoring

### Contributed to Upstream üéØ
- (Track upstream PRs here as we create them)

